const router = require("express").Router();
const bcrypt = require("bcrypt");
const User = require("../Models/User_Model");
const JWT_AUTH = require("../middlewares/JWT");
const jwt = require("jsonwebtoken");
const {
    generateToken,
    sendVerificationEmail,
    generateOTP,
} = require("../email util/EmailService");
const Token = require("../Models/Verify_token");
const Otp = require("../Models/OTP_Model");

router.post("/register-user", async (req, res) => {
    try {
        //console.log(req.body);

        const isUserExisting = await User.find({
            email: req.body.userDetails.email,
        });

        if (isUserExisting.length) {
            //console.log("user already exists");


            // if (!isUserExisting[0].isVerified) {
            //     return res
            //         .status(400)
            //         .json({ error: `User ${req.body.userDetails.email} already exists` });
            // }

            if (req.body.userDetails.isAutogenerated && isUserExisting[0].email === req.body.userDetails.email) {
                const payload = {
                    userId: isUserExisting[0]._id,
                    email: isUserExisting[0].email,
                    name: isUserExisting[0].name
                };


                // Generate JWT token with expiration time
                const token = jwt.sign(payload, process.env.SECRET, { expiresIn: "24hr" });

                return res.status(200).json({ message: "Logging in with GOOGLE", token })
            }
            else {

                return res
                    .status(400)
                    .json({ error: `User ${req.body.userDetails.email} already exists` });
            }
        }

        //console.log(isUserExisting);

        const hashedPassword = await bcrypt.hash(req.body.userDetails.password, 10);

        let password = req.body.userDetails.password

        req.body.userDetails.password = hashedPassword;

        req.body.userDetails.isAutogenerated ? req.body.userDetails.isVerified = true : false;

        const newUser = await User(req.body.userDetails);

        try {
            if (req.body.userDetails.isAutogenerated) {
                // Generate JWT token with expiration time

                const payload = {
                    // userId: isUserExisting._id,
                    email: req.body.userDetails.email,
                    name: req.body.userDetails.name
                };
                const token = jwt.sign(payload, process.env.SECRET, { expiresIn: "1m" });

                await sendVerificationEmail(newUser.email, null, "autogenerated", { password });
                await newUser.save();
                return res.status(200).json({ message: "DIRECT LOGIN", token })
            } else {

                const verifyToken = generateToken();

                await Token.create({ email: newUser.email, token: verifyToken });


                await sendVerificationEmail(newUser.email, verifyToken);
            }

            await newUser.save();

            return res
                .status(200)
                .json({ message: "Please check you inbox to verfy your account" });
        } catch (error) {
            return res.json({ error: error.message });
        }
    } catch (error) {
        //console.log(error);
    }
});

router.post("/login-user", async (req, res) => {

    //console.log("hekjahekjrh");
    try {
        const isUserExisting = await User.findOne({
            email: req.body.userDetails.email,
        });

        if (!isUserExisting) {
            return res
                .status(404)
                .json({
                    error: `User not found with the email ${req.body.userDetails.email}`,
                });
        }


        if (!isUserExisting.isVerified) {
            return res.status(400).json({ error: `User is not verified` })
        }


        const ispasswordCorrect = await bcrypt.compare(
            req.body.userDetails.password,
            isUserExisting.password
        );

        if (!ispasswordCorrect) {
            return res.status(401).json({ error: "Invalid credentials" });
        }

        const payload = {
            userId: isUserExisting._id,
            email: isUserExisting.email,
            name: isUserExisting.name
        };

        // Define expiration time (10 seconds)


        // Generate JWT token with expiration time
        const token = jwt.sign(payload, process.env.SECRET, { expiresIn: "24h" });

        // const token = jwt.sign(payload, process.env.SECRET, { expiresIn: new Date });

        return res.status(200).json({ token: token });
    } catch (error) {
        return res.status(500).json({ error: error.message });
    }
});

router.get("/verify", async (req, res) => {
    const { token } = req.query;

    try {
        const data = await Token.findOneAndDelete({ token });

        //console.log(data);

        if (data) {


            await User.findOneAndUpdate({ email: data.email }, { isVerified: true })

            res.status(200).json({ message: `${data.email} is now verified` });
        } else {
            res.status(400).json({ error: "Token has expired" })
        }


    } catch (error) {
        res.status(500).send({ error: error.message });
    }
});



router.post('/getVerificationEmail', async (req, res) => {

    try {

        const email = req.body.email;

        const verifyToken = generateToken();

        await Token.create({ email: email, token: verifyToken });

        await sendVerificationEmail(email, verifyToken);

        res.status(200).json("Please check your inbox to verify")

    } catch (error) {
        res.status(500).json("Something went wrong")

    }

})



router.post("/resetPassword", async (req, res) => {

    try {


        const email = req.body.email

        const otp = generateOTP(6);

        await Otp.create({ email: email, otp });

        await sendVerificationEmail(email, otp, "resetPassword");

        res.status(200).json({ message: "OTP Sent successfully" })


    } catch (error) {

        //console.log(error);
        res.status(500).json({ error })


    }

})



router.post('/verifyOTP', async (req, res) => {

    try {
        const otp = req.body.otp


        const isValidOTP = await Otp.findOneAndDelete({ otp })

        if (isValidOTP) {

            res.status(200).json({ message: "OTP verification successful" })

        } else {
            res.status(400).json({ message: "OTP has expired or invalid" })
        }

    } catch (error) {
        res.status(500).json({ error })

    }

})


router.put("/updateDetails", JWT_AUTH, async (req, res) => {


    try {

        //console.log(req.body);
        const { updateType, userDetails } = req.body

        if (updateType === "password") {

            const newPassword = await bcrypt.hash(userDetails.password, 10)

            const response = await User.findOneAndUpdate({ email: userDetails.email }, { password: newPassword })


            await sendVerificationEmail(userDetails.email, "", "PasswordResetSuccess")

            return res.status(200).json({ success: "Password updated" })

        }
        if (updateType === "username") {



            const response = await User.findOneAndUpdate({ email: userDetails.email }, { name: userDetails.name })


            //console.log(response);
            await sendVerificationEmail(userDetails.email, "", "NameUpdateSuccess")


            return res.status(200).json({ success: "Username updated", updatedName: userDetails.name })

        }
    } catch (error) {

        //console.log(error);

    }


})



router.post('/userByEmail', async (req, res) => {
    try {
        const user = await User.findOne({ email: req.body.email });

        if (!user) {
            return res.status(404).json({ message: "User not found" });
        }

        const userWithoutPassword = {
            email: user.email,
            name: user.name,
        };

        //console.log(userWithoutPassword);

        return res.status(200).json(userWithoutPassword);
    } catch (error) {
        //console.error(error);
        return res.status(500).json({ message: "Internal server error" });
    }
});




module.exports = router;
